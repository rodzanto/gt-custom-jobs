{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nexports.__esModule = true;\n\nvar lodash_sortby_1 = __importDefault(require(\"lodash.sortby\"));\n\nexports.splitWithOffsets = function (text, offsets) {\n  var lastEnd = 0;\n  var splits = [];\n\n  for (var _i = 0, _a = lodash_sortby_1[\"default\"](offsets, function (o) {\n    return o.start;\n  }); _i < _a.length; _i++) {\n    var offset = _a[_i];\n    var start = offset.start,\n        end = offset.end;\n\n    if (lastEnd < start) {\n      splits.push({\n        start: lastEnd,\n        end: start,\n        content: text.slice(lastEnd, start)\n      });\n    }\n\n    splits.push(__assign(__assign({}, offset), {\n      mark: true,\n      content: text.slice(start, end)\n    }));\n    lastEnd = end;\n  }\n\n  if (lastEnd < text.length) {\n    splits.push({\n      start: lastEnd,\n      end: text.length,\n      content: text.slice(lastEnd, text.length)\n    });\n  }\n\n  return splits;\n};\n\nexports.splitTokensWithOffsets = function (text, offsets) {\n  var lastEnd = 0;\n  var splits = [];\n\n  for (var _i = 0, _a = lodash_sortby_1[\"default\"](offsets, function (o) {\n    return o.start;\n  }); _i < _a.length; _i++) {\n    var offset = _a[_i];\n    var start = offset.start,\n        end = offset.end;\n\n    if (lastEnd < start) {\n      for (var i = lastEnd; i < start; i++) {\n        splits.push({\n          i: i,\n          content: text[i]\n        });\n      }\n    }\n\n    splits.push(__assign(__assign({}, offset), {\n      mark: true,\n      content: text.slice(start, end).join(' ')\n    }));\n    lastEnd = end;\n  }\n\n  for (var i = lastEnd; i < text.length; i++) {\n    splits.push({\n      i: i,\n      content: text[i]\n    });\n  }\n\n  return splits;\n};\n\nexports.selectionIsEmpty = function (selection) {\n  var position = selection.anchorNode.compareDocumentPosition(selection.focusNode);\n  return position === 0 && selection.focusOffset === selection.anchorOffset;\n};\n\nexports.selectionIsBackwards = function (selection) {\n  if (exports.selectionIsEmpty(selection)) return false;\n  var position = selection.anchorNode.compareDocumentPosition(selection.focusNode);\n  var backward = false;\n  if (!position && selection.anchorOffset > selection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) backward = true;\n  return backward;\n};","map":null,"metadata":{},"sourceType":"script"}